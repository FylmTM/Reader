<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Team.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2019-12-11T09:35:15Z</updated>

    
    <entry>
        <title>Launching the 2019 State of Rust Survey</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/12/03/survey-launch.html" type="text/html" title="Launching the 2019 State of Rust Survey" />
        <published>2019-12-03T00:00:00Z</published>
        <updated>2019-12-03T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/12/03/survey-launch.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/12/03/survey-launch.html">&lt;p&gt;It's that time again! Time for us to take a look at how the Rust project is doing, and what we should plan for the future. The Rust Community Team is pleased to announce our &lt;a href=&quot;https://docs.google.com/forms/d/1iGnf8Mmf4JRggOJ3E7iZlBLsgeLxIYzaI1caiFHQ6OQ/viewform&quot;&gt;2019 State of Rust Survey&lt;/a&gt;! Whether or not you use Rust today, we want to know your opinions. Your responses will help the project understand its strengths and weaknesses and establish development priorities for the future.&lt;/p&gt;
&lt;p&gt;Completing this survey should take about 10–15 minutes and is anonymous unless you choose to give us your contact information. We will be accepting submissions until December 16th, and we will write up our findings a month or so afterwards to &lt;a href=&quot;https://blog.rust-lang.org&quot;&gt;blog.rust-lang.org&lt;/a&gt;. You can also check out &lt;a href=&quot;https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html&quot;&gt;last year’s results&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/1iGnf8Mmf4JRggOJ3E7iZlBLsgeLxIYzaI1caiFHQ6OQ/viewform&quot;&gt;English&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wj.qq.com/s2/5080757/5237&quot;&gt;Simplified Chinese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSfMugzbkuwY_x2sKm1Jt2Y569ULG2mLE_hOzZFIUpjO1vXmzg/viewform?hl=zh-TW&quot;&gt;Traditional Chinese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSeiIlKDo-3PGS4yxAQ2PwIL1NmPSua0AnktgaaI2ZWa1iOC2g/viewform?hl=fr&quot;&gt;French&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLScjz_tD9UQQPbxeiQVMbD5RIHvoob5Du9VQp8yjatfcE6CuCw/viewform?hl=de&quot;&gt;German&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSdtFimO_-WL8Ja7PdG0MgLJJKIau9qOtBZLLca9TeK1tiA19g/viewform?hl=it&quot;&gt;Italian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSe-AakTxBDKSBZUk1zTqvZ749M-wAPHUU45Pnj12-0-Y_Qxaw/viewform?hl=jp&quot;&gt;Japanese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLScPqYek5LKDyLBnB3NM3X5YTLjLolIjc_j0SFewAzBgUZd5Wg/viewform?hl=ko&quot;&gt;Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSdyZ6Xg7d-VIJpRCdLaTocSYOWd1eDI6VryS954fl_ESJYx4Q/viewform?hl=pl&quot;&gt;Polish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLScIZI8qtS1BMBaOIIirwp_NngKWgr_GTnow6Fp32M8_IySaPw/viewform?hl=pt&quot;&gt;Portuguese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSd6nhdpmopSM_3xikVEDnHAem1yKq76ymQx0nINUFHqkqC-LA/viewform?hl=ru&quot;&gt;Russian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSekNvJgid_RrixnHm2aOAqLf4sCFUVOVVakTh97ILLNyTsQSA/viewform?hl=es&quot;&gt;Spanish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSdw5T3chMuQi72QiMk_Nu6Kb44qSIRKrjxcHBQVVK6RpebpvQ/viewform?hl=sv&quot;&gt;Swedish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSe5eEQxuf38XQEKPUXjdCgsB8WinsnC2NpA17Bq1WyPkX8TXg/viewform?hl=vn&quot;&gt;Vietnamese&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(If you speak multiple languages, please pick one)&lt;/p&gt;
&lt;p&gt;Please help us spread the word by sharing the survey link on your social network feeds, at meetups, around your office, and in other communities.&lt;/p&gt;
&lt;p&gt;If you have any questions, please see our &lt;a href=&quot;https://forge.rust-lang.org/community/survey-faq.html&quot;&gt;frequently asked questions&lt;/a&gt; or email the Rust Community team at &lt;a href=&quot;mailto:community-team@rust-lang.org&quot;&gt;community-team@rust-lang.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, we wanted to thank everyone who helped develop, polish, and test the survey. In particular we'd like to thank &lt;a href=&quot;https://isu.edu/cmp/faculty-and-staff/facultyandstaff/d-jasun-carr.html&quot;&gt;Dr. Jasun Carr&lt;/a&gt;, for providing their expertise in communication processes with helping to create this year's survey, and all of the volunteers who worked to provide all of the translations available this year.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Community Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.39.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/11/07/Rust-1.39.0.html" type="text/html" title="Announcing Rust 1.39.0" />
        <published>2019-11-07T00:00:00Z</published>
        <updated>2019-11-07T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/11/07/Rust-1.39.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/11/07/Rust-1.39.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.39.0. Rust is a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.39.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1390-2019-11-07&quot;&gt;detailed release notes for 1.39.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.39.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.39.0-stable&quot;&gt;&lt;/a&gt;What's in 1.39.0 stable&lt;/h2&gt;
&lt;p&gt;The highlights of Rust 1.39.0 include &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;.await&lt;/code&gt;, shared references to by-move bindings in &lt;code&gt;match&lt;/code&gt; guards, and attributes on function parameters. Also, see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1390-2019-11-07&quot;&gt;detailed release notes&lt;/a&gt; for additional information.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#the-await-is-over,-async-fns-are-here&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-await-is-over,-async-fns-are-here&quot;&gt;&lt;/a&gt;The &lt;code&gt;.await&lt;/code&gt; is over, &lt;code&gt;async fn&lt;/code&gt;s are here&lt;/h3&gt;
&lt;p&gt;Previously in Rust 1.36.0, &lt;a href=&quot;https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html#the-future-is-here&quot;&gt;we announced&lt;/a&gt; that the &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/future/trait.Future.html&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; trait is here. Back then, we noted that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;With this stabilization, we hope to give important crates, libraries, and the ecosystem time to prepare for &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;.await&lt;/code&gt;, which we'll tell you more about in the future.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A promise made is a promise kept. So in Rust 1.39.0, we are pleased to announce that &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;.await&lt;/code&gt; is stabilized! Concretely, this means that you can define &lt;code&gt;async&lt;/code&gt; functions and blocks and &lt;code&gt;.await&lt;/code&gt; them.&lt;/p&gt;
&lt;p&gt;An &lt;code&gt;async&lt;/code&gt; function, which you can introduce by writing &lt;code&gt;async fn&lt;/code&gt; instead of &lt;code&gt;fn&lt;/code&gt;, does nothing other than to return a &lt;code&gt;Future&lt;/code&gt; when called. This &lt;code&gt;Future&lt;/code&gt; is a suspended computation which you can drive to completion by &lt;code&gt;.await&lt;/code&gt;ing it. Besides &lt;code&gt;async fn&lt;/code&gt;, &lt;code&gt;async { ... }&lt;/code&gt; and &lt;code&gt;async move { ... }&lt;/code&gt; blocks, which act like closures, can be used to define &amp;quot;async literals&amp;quot;.&lt;/p&gt;
&lt;p&gt;For more on the release of &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;.await&lt;/code&gt;, read &lt;a href=&quot;https://blog.rust-lang.org/2019/11/07/Async-await-stable.html&quot;&gt;Niko Matsakis's blog post&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#references-to-by-move-bindings-in-match-guards&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;references-to-by-move-bindings-in-match-guards&quot;&gt;&lt;/a&gt;References to by-move bindings in &lt;code&gt;match&lt;/code&gt; guards&lt;/h3&gt;
&lt;p&gt;When pattern matching in Rust, a variable, also known as a &amp;quot;binding&amp;quot;, can be bound in the following ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;by-reference, either immutably or mutably. This can be achieved explicitly e.g. through &lt;code&gt;ref my_var&lt;/code&gt; or &lt;code&gt;ref mut my_var&lt;/code&gt; respectively. Most of the time though, the binding mode will be inferred automatically.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;by-value -- either by-copy, when the bound variable's type implements &lt;code&gt;Copy&lt;/code&gt;, or otherwise &lt;strong&gt;&lt;em&gt;by-move&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Previously, Rust would forbid taking shared references to &lt;strong&gt;&lt;em&gt;by-move&lt;/em&gt;&lt;/strong&gt; bindings in the &lt;code&gt;if&lt;/code&gt; guards of &lt;code&gt;match&lt;/code&gt; expressions. This meant that the following code would be rejected:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let array: Box&amp;lt;[u8; 4]&amp;gt; = Box::new([1, 2, 3, 4]);

    match array {
        nums
//      ---- `nums` is bound by move.
            if nums.iter().sum::&amp;lt;u8&amp;gt;() == 10
//                 ^------ `.iter()` implicitly takes a reference to `nums`.
        =&amp;gt; {
            drop(nums);
//          ----------- `nums` was bound by move and so we have ownership.
        }
        _ =&amp;gt; unreachable!(),
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/63118/#issuecomment-522823925&quot;&gt;With Rust 1.39.0&lt;/a&gt;, the snippet above is now accepted by the compiler. We hope that this will give a smoother and more consistent experience with &lt;code&gt;match&lt;/code&gt; expressions overall.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#attributes-on-function-parameters&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;attributes-on-function-parameters&quot;&gt;&lt;/a&gt;Attributes on function parameters&lt;/h3&gt;
&lt;p&gt;With Rust 1.39.0, attributes are now allowed on parameters of functions, closures, and function pointers. Whereas before, you might have written:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[cfg(windows)]
fn len(slice: &amp;amp;[u16]) -&amp;gt; usize {
    slice.len()
}
#[cfg(not(windows))] 
fn len(slice: &amp;amp;[u8]) -&amp;gt; usize {
    slice.len()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...&lt;a href=&quot;https://github.com/rust-lang/rust/pull/64010/&quot;&gt;you can now&lt;/a&gt;, more succinctly, write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn len(
    #[cfg(windows)] slice: &amp;amp;[u16], // This parameter is used on Windows.
    #[cfg(not(windows))] slice: &amp;amp;[u8], // Elsewhere, this one is used.
) -&amp;gt; usize {
    slice.len()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The attributes you can use in this position include:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Conditional compilation: &lt;code&gt;cfg&lt;/code&gt; and &lt;code&gt;cfg_attr&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Controlling lints: &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt;, and &lt;code&gt;forbid&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Helper attributes used by procedural macro attributes applied to items.&lt;/p&gt;
&lt;p&gt;Our hope is that this will be used to provide more readable and ergonomic macro-based DSLs throughout the ecosystem.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;a href=&quot;#borrow-check-migration-warnings-are-hard-errors-in-rust-2018&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;borrow-check-migration-warnings-are-hard-errors-in-rust-2018&quot;&gt;&lt;/a&gt;Borrow check migration warnings are hard errors in Rust 2018&lt;/h3&gt;
&lt;p&gt;In the 1.35.0 release, &lt;a href=&quot;https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html#nll-for-rust-2015&quot;&gt;we announced&lt;/a&gt; that NLL had come to Rust 2015 after first being released for Rust 2018 in &lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes&quot;&gt;1.31&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As noted in the 1.35.0 release, the old borrow checker had some bugs which would allow memory unsafety. These bugs were fixed by the NLL borrow checker. As these fixes broke some stable code, we decided to gradually phase in the errors by checking if the old borrow checker would accept the program and the NLL checker would reject it. If so, the errors would instead become warnings.&lt;/p&gt;
&lt;p&gt;With Rust 1.39.0, these warnings are now &lt;a href=&quot;https://github.com/rust-lang/rust/pull/63565&quot;&gt;errors in Rust 2018&lt;/a&gt;.
In the next release, Rust 1.40.0, &lt;a href=&quot;https://github.com/rust-lang/rust/pull/64221&quot;&gt;this will also apply to Rust 2015&lt;/a&gt;, which will finally allow us to &lt;a href=&quot;https://github.com/rust-lang/rust/pull/64790&quot;&gt;remove the old borrow checker&lt;/a&gt;, and keep the compiler clean.&lt;/p&gt;
&lt;p&gt;If you are affected, or want to hear more, read &lt;a href=&quot;https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html&quot;&gt;Niko Matsakis's blog post&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#more-const-fns-in-the-standard-library&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;more-const-fns-in-the-standard-library&quot;&gt;&lt;/a&gt;More &lt;code&gt;const fn&lt;/code&gt;s in the standard library&lt;/h3&gt;
&lt;p&gt;With Rust 1.39.0, the following functions became &lt;code&gt;const fn&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/std/string/struct.String.html#method.new&quot;&gt;&lt;code&gt;String::new&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/std/collections/linked_list/struct.LinkedList.html#method.new&quot;&gt;&lt;code&gt;LinkedList::new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.len&quot;&gt;&lt;code&gt;str::len&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.len&quot;&gt;&lt;code&gt;[T]::len&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes&quot;&gt;&lt;code&gt;str::as_bytes&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.i8.html#method.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.i8.html#method.wrapping_abs&quot;&gt;&lt;code&gt;wrapping_abs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.i8.html#method.overflowing_abs&quot;&gt;&lt;code&gt;overflowing_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#additions-to-the-standard-library&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;additions-to-the-standard-library&quot;&gt;&lt;/a&gt;Additions to the standard library&lt;/h3&gt;
&lt;p&gt;In Rust 1.39.0 the following functions were stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/pin/struct.Pin.html#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Instant.html#method.checked_duration_since&quot;&gt;&lt;code&gt;Instant::checked_duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Instant.html#method.saturating_duration_since&quot;&gt;&lt;code&gt;Instant::saturating_duration_since&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#other-changes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.39.0 release: check out what changed in &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1390-2019-11-07&quot;&gt;Rust&lt;/a&gt;, &lt;a href=&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-139-2019-11-07&quot;&gt;Cargo&lt;/a&gt;, and &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-139&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Please also see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#compatibility-notes&quot;&gt;compatibility notes&lt;/a&gt; to check if you're affected by those changes.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-139.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-139.0&quot;&gt;&lt;/a&gt;Contributors to 1.39.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.39.0. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.39.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Async-await on stable Rust!</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/11/07/Async-await-stable.html" type="text/html" title="Async-await on stable Rust!" />
        <published>2019-11-07T00:00:00Z</published>
        <updated>2019-11-07T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/11/07/Async-await-stable.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/11/07/Async-await-stable.html">&lt;p&gt;&lt;strong&gt;On this coming Thursday, November 7, async-await syntax hits stable
Rust, as part of the 1.39.0 release.&lt;/strong&gt; This work has been a long time
in development -- the key ideas for zero-cost futures, for example,
were &lt;a href=&quot;https://aturon.github.io/blog/2016/08/11/futures/&quot;&gt;first proposed by Aaron Turon and Alex Crichton in
2016&lt;/a&gt;! -- and we are very proud of the end result. We believe
that Async I/O is going to be an increasingly important part of Rust's
story.&lt;/p&gt;
&lt;p&gt;While this first release of &amp;quot;async-await&amp;quot; is a momentous event, it's
also only the beginning. The current support for async-await marks a
kind of &amp;quot;Minimum Viable Product&amp;quot; (MVP). We expect to be polishing,
improving, and extending it for some time.&lt;/p&gt;
&lt;p&gt;Already, in the time since &lt;a href=&quot;https://blog.rust-lang.org/2019/09/30/Async-await-hits-beta.html&quot;&gt;async-await hit beta&lt;/a&gt;, we've made
a lot of great progress, including making some &lt;a href=&quot;https://blog.rust-lang.org/inside-rust/2019/10/11/AsyncAwait-Not-Send-Error-Improvements.html&quot;&gt;key diagnostic
improvements&lt;/a&gt; that help to make async-await errors far more
approachable. To get involved in that work, check out
the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/&quot;&gt;Async Foundations Working Group&lt;/a&gt;; if nothing else, you can
help us by filing bugs about polish issues or by &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/#nominating-issues&quot;&gt;nominating those
bugs that are bothering you the most&lt;/a&gt;, to help direct our
efforts.&lt;/p&gt;
&lt;p&gt;Many thanks are due to the people who made async-await a reality. The
implementation and design would never have happened without the
leadership of cramertj and withoutboats, the implementation and polish
work from the compiler side (davidtwco, tmandry, gilescope, csmoe),
the core generator support that futures builds on (Zoxc), the
foundational work on &lt;code&gt;Future&lt;/code&gt; and the &lt;code&gt;Pin&lt;/code&gt; APIs (aturon,
alexcrichton, RalfJ, pythonesque), and of course the input provided by
so many community members on RFC threads and discussions.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#major-developments-in-the-async-ecosystem&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;major-developments-in-the-async-ecosystem&quot;&gt;&lt;/a&gt;Major developments in the async ecosystem&lt;/h1&gt;
&lt;p&gt;Now that async-await is approaching stabilization, all the major Async
I/O runtimes are at work adding and extending their support for the
new syntax:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href=&quot;https://tokio.rs/&quot;&gt;tokio&lt;/a&gt; runtime &lt;a href=&quot;https://tokio.rs/blog/2019-10-scheduler/&quot;&gt;recently announced a number of scheduler
improvements&lt;/a&gt;, and they are planning a stable release
in November that supports async-await syntax;&lt;/li&gt;
&lt;li&gt;the &lt;a href=&quot;https://async.rs/&quot;&gt;async-std&lt;/a&gt; runtime &lt;a href=&quot;https://github.com/async-rs/async-std/releases&quot;&gt;has been putting out weekly releases for the past few months&lt;/a&gt;, and plans to make their
1.0 release shortly after async-await hits stable;&lt;/li&gt;
&lt;li&gt;using &lt;a href=&quot;https://docs.rs/crate/wasm-bindgen-futures/0.2.16&quot;&gt;wasm-bindgen-futures&lt;/a&gt;, you can even bridge Rust Futures with
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;JavaScript promises&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;the &lt;a href=&quot;https://hyper.rs&quot;&gt;hyper library&lt;/a&gt; has &lt;a href=&quot;https://github.com/hyperium/hyper/issues/1805&quot;&gt;migrated&lt;/a&gt; to adopt standard Rust futures;&lt;/li&gt;
&lt;li&gt;the newly released 0.3.0 version of the &lt;a href=&quot;https://crates.io/crates/futures&quot;&gt;futures-rs library&lt;/a&gt; includes support
for async-await;&lt;/li&gt;
&lt;li&gt;finally, async-await support is starting to become available in higher-level
&lt;a href=&quot;https://www.arewewebyet.org/topics/frameworks/&quot;&gt;web frameworks&lt;/a&gt; as well, as well as other interesting applications such
as the &lt;a href=&quot;https://docs.rs/futures-intrusive/0.2.0/futures_intrusive/&quot;&gt;&lt;code&gt;futures_intrusive&lt;/code&gt;&lt;/a&gt;
crate.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#async-await-a-quick-primer&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;async-await-a-quick-primer&quot;&gt;&lt;/a&gt;Async-await: a quick primer&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;(This section and the next are reproduced from the &lt;a href=&quot;https://blog.rust-lang.org/2019/09/30/Async-await-hits-beta.html&quot;&gt;&amp;quot;Async-await hits
beta!&amp;quot;&lt;/a&gt; post.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So, what is async await? Async-await is a way to write functions that
can &amp;quot;pause&amp;quot;, return control to the runtime, and then pick up from
where they left off.  Typically those pauses are to wait for I/O, but
there can be any number of uses.&lt;/p&gt;
&lt;p&gt;You may be familiar with the async-await from JavaScript or C#. Rust's
version of the feature is similar, but with a few key differences.&lt;/p&gt;
&lt;p&gt;To use async-await, you start by writing &lt;code&gt;async fn&lt;/code&gt; instead of &lt;code&gt;fn&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn first_function() -&amp;gt; u32 { .. }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unlike a regular function, calling an &lt;code&gt;async fn&lt;/code&gt; doesn't have any
immediate effect. Instead, it returns a &lt;code&gt;Future&lt;/code&gt;. This is a suspended
computation that is waiting to be executed. To actually &lt;em&gt;execute&lt;/em&gt; the
future, use the &lt;code&gt;.await&lt;/code&gt; operator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn another_function() {
    // Create the future:
    let future = first_function();
    
    // Await the future, which will execute it (and suspend
    // this function if we encounter a need to wait for I/O): 
    let result: u32 = future.await;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This example shows the first difference between Rust and other
languages: we write &lt;code&gt;future.await&lt;/code&gt; instead of &lt;code&gt;await future&lt;/code&gt;. This
syntax integrates better with Rust's &lt;code&gt;?&lt;/code&gt; operator for propagating
errors (which, after all, are very common in I/O). You can simply
write &lt;code&gt;future.await?&lt;/code&gt; to await the result of a future and propagate
errors. It also has the advantage of making method chaining painless.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#zero-cost-futures&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;zero-cost-futures&quot;&gt;&lt;/a&gt;Zero-cost futures&lt;/h3&gt;
&lt;p&gt;The other difference between Rust futures and futures in JS and C# is
that they are based on a &amp;quot;poll&amp;quot; model, which makes them &lt;strong&gt;zero
cost&lt;/strong&gt;. In other languages, invoking an async function immediately
creates a future and schedules it for execution: awaiting the future
isn't necessary for it to execute. But this implies some overhead for
each future that is created.&lt;/p&gt;
&lt;p&gt;In contrast, in Rust, calling an async function does not do any
scheduling in and of itself, which means that we can compose a complex
nest of futures without incurring a per-future cost. As an end-user,
though, the main thing you'll notice is that &lt;strong&gt;futures feel &amp;quot;lazy&amp;quot;&lt;/strong&gt;:
they don't do anything until you await them.&lt;/p&gt;
&lt;p&gt;If you'd like a closer look at how futures work under the hood, take a
look at &lt;a href=&quot;https://rust-lang.github.io/async-book/02_execution/04_executor.html&quot;&gt;the executor section&lt;/a&gt; of the &lt;a href=&quot;https://github.com/rust-lang/async-book&quot;&gt;async book&lt;/a&gt;, or watch the
&lt;a href=&quot;https://www.youtube.com/watch?v=skos4B5x7qE&quot;&gt;excellent talk&lt;/a&gt; that &lt;a href=&quot;https://github.com/withoutboats&quot;&gt;withoutboats&lt;/a&gt; gave at &lt;a href=&quot;https://rustlatam.org/&quot;&gt;Rust LATAM 2019&lt;/a&gt;
on the topic.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#summary&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;summary&quot;&gt;&lt;/a&gt;Summary&lt;/h3&gt;
&lt;p&gt;We believe that having async-await on stable Rust is going to be a key
enabler for a lot of new and exciting developments in Rust. If you've
tried Async I/O in Rust in the past and had problems -- particularly
if you tried the combinator-based futures of the past -- you'll find
&lt;a href=&quot;http://aturon.github.io/tech/2018/04/24/async-borrowing/&quot;&gt;async-await integrates much better with Rust's borrowing
system&lt;/a&gt;. Moreover, there are now a number of great runtimes and
other libraries available in the ecosystem to work with.  So get out
there and build stuff!&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Completing the transition to the new borrow checker</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html" type="text/html" title="Completing the transition to the new borrow checker" />
        <published>2019-11-01T00:00:00Z</published>
        <updated>2019-11-01T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html">&lt;p&gt;For most of 2018, we've been issuing warnings about various bugs in the
borrow checker that we plan to fix -- about two months ago, in the
current Rust nightly, those warnings became &lt;strong&gt;hard errors&lt;/strong&gt;. In about
two weeks, when the nightly branches to become beta, those hard errors
will be in the beta build, and they will eventually hit stable on
December 19th, as part of Rust 1.40.0. &lt;strong&gt;If you're testing with
Nightly, you should be all set -- but otherwise, you may want to go
and check to make sure your code still builds. If not, we have advice
for fixing common problems below.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#background-the-non-lexical-lifetime-transition&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;background-the-non-lexical-lifetime-transition&quot;&gt;&lt;/a&gt;Background: the non-lexical lifetime transition&lt;/h3&gt;
&lt;p&gt;When we &lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html&quot;&gt;released Rust 2018 in Rust 1.31&lt;/a&gt;, it included a new
version of the borrow checker, one that implemented &lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes&quot;&gt;&amp;quot;non-lexical
lifetimes&amp;quot;&lt;/a&gt;. This new borrow checker did a much more precise
analysis than the original, allowing us to eliminate a lot of
unnecessary errors and make Rust easier to use. I think most everyone
who was using Rust 2015 can attest that this shift was a big
improvement.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#the-new-borrow-checker-also-fixed-a-lot-of-bugs&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-new-borrow-checker-also-fixed-a-lot-of-bugs&quot;&gt;&lt;/a&gt;The new borrow checker also fixed a lot of bugs&lt;/h3&gt;
&lt;p&gt;What is perhaps less well understood is that the new borrow checker
implementation &lt;em&gt;also&lt;/em&gt; fixed a lot of bugs. In other words, the new
borrow checker did not just accept more programs -- &lt;strong&gt;it also rejected
some programs that were only accepted in the first place due to memory
unsafety bugs in the old borrow checker!&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#until-recently-those-fixed-bugs-produced-warnings,-not-errors&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;until-recently-those-fixed-bugs-produced-warnings,-not-errors&quot;&gt;&lt;/a&gt;Until recently, those fixed bugs produced warnings, not errors&lt;/h3&gt;
&lt;p&gt;Obviously, we don't want to accept programs that could undermine
Rust's safety guarantees. At the same time, as part of our commitment
to stability, we try to avoid making sudden bug fixes that will affect
a lot of code. Whenever possible, we prefer to &amp;quot;phase in&amp;quot; those
changes gradually. We usually begin with &amp;quot;Future Compatibility
Warnings&amp;quot;, for example, before moving those warnings to hard errors
(sometimes a small bit at a time). Since the bug fixes to the borrow
checker affected a lot of crates, we knew we needed a warning period
before we could make them into hard errors.&lt;/p&gt;
&lt;p&gt;To implement this warning period, we kept two copies of the borrow
checker around (this is a trick we use quite frequently, actually).
The new checker ran first. If it found errors, we didn't report them
directly: instead, we ran the old checker in order to see if the crate
&lt;em&gt;used&lt;/em&gt; to compile before. If so, we reported the errors as Future
Compatibility Warnings, since we were changing something that used to
compile into errors.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#all-good-things-must-come-to-an-end-and-bad-ones,-too&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;all-good-things-must-come-to-an-end-and-bad-ones,-too&quot;&gt;&lt;/a&gt;All good things must come to an end; and bad ones, too&lt;/h3&gt;
&lt;p&gt;Over time we have been slowly transitioning those future compatibility
warnings into errors, a bit at a time. About two months ago, we
decided that the time had come to finish the job. So, over the course
of two PRs, we &lt;a href=&quot;https://github.com/rust-lang/rust/pull/63565&quot;&gt;converted all remaining warnings to errors&lt;/a&gt; and
then &lt;a href=&quot;https://github.com/rust-lang/rust/pull/64790&quot;&gt;removed the old borrow checker implementation&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#what-this-means-for-you&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-this-means-for-you&quot;&gt;&lt;/a&gt;What this means for you&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;If you are testing your package with nightly, then you should be
fine.&lt;/strong&gt; In fact, even if you build on stable, we always recommend that
you test your builds in CI with the nightly build, so that you can
identify upcoming issues early and report them to us.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Otherwise, you may want to check your dependencies.&lt;/strong&gt; When we
decided to remove the old borrow checker, we also analyzed which
crates would stop compiling. For anything that seemed to be widely
used, we made sure that there were newer versions of that crate
available that &lt;em&gt;do&lt;/em&gt; compile (for the most part, this had all already
happened during the warning period). But if you have those older
versions in your &lt;code&gt;Cargo.lock&lt;/code&gt; file, and you are only using stable
builds, then you may find that your code no longer builds once 1.40.0
is released -- you will have to upgrade the dependency.&lt;/p&gt;
&lt;p&gt;The most common crates that were affected are the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt; version 1.7.0 -- you can upgrade to 1.7.2, though you'd be better off upgrading to 2.1.0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nalgebra&lt;/code&gt; version 0.16.13 -- you can upgrade to 0.16.14, though you'd be better off upgrading to 0.19.0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rusttype&lt;/code&gt; version 0.2.0 to 0.2.3 -- you can upgrade to 0.2.4, though you'd be better upgrading to 0.8.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find out which crates you rely upon using the &lt;a href=&quot;https://crates.io/crates/cargo-tree&quot;&gt;cargo-tree&lt;/a&gt; command. If you find
that you &lt;em&gt;do&lt;/em&gt; rely (say) on &lt;code&gt;url&lt;/code&gt; 1.7.0, you can upgrade to 1.7.2 by executing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cargo update --package url --precise 1.7.2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#want-to-learn-more&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;want-to-learn-more&quot;&gt;&lt;/a&gt;Want to learn more?&lt;/h3&gt;
&lt;p&gt;If you'd like to learn more about the kinds of bugs that were fixed --
or if you are seeing errors in your code that you need to fix -- take
a look at this &lt;a href=&quot;http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/&quot;&gt;excellent blog post by Felix Klock&lt;/a&gt;, which
goes into great detail.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>A call for blogs 2020</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html" type="text/html" title="A call for blogs 2020" />
        <published>2019-10-29T00:00:00Z</published>
        <updated>2019-10-29T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html">&lt;p&gt;What will Rust development look like in 2020? That's partially up to you! Here's how it works:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Anyone and everyone in the Rust community writes a blog post about what they'd like Rust development to be like in 2020.&lt;/li&gt;
&lt;li&gt;The core team reads all the posts, and writes up a &amp;quot;Roadmap RFC&amp;quot; to make a formal proposal.&lt;/li&gt;
&lt;li&gt;The RFC is reviewed by everyone, comments are made, adjustments are made, and eventually it is accepted.&lt;/li&gt;
&lt;li&gt;This RFC is a guide to either accept or postpone RFCs for 2020. If a proposal fits into the themes of what we want to accomplish, we'll take it, but if it doesn't, we'll put it off until the next year.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This process takes time, and it won't &lt;em&gt;quite&lt;/em&gt; be complete before 2020 starts.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We'll review the posts December 1. That gives you a month to think about Rust in 2020 and write something up.&lt;/li&gt;
&lt;li&gt;We'll aim to produce the RFC draft in the week or two after&lt;/li&gt;
&lt;li&gt;Depending on how many comments the RFC gets, we may not end up accepting it until early January.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#what-were-looking-for&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-were-looking-for&quot;&gt;&lt;/a&gt;What we're looking for&lt;/h2&gt;
&lt;p&gt;We are accepting ideas about almost anything having to do with Rust: language features, tooling needs, community programs, ecosystem needs... if it's related to Rust, we want to hear about it.&lt;/p&gt;
&lt;p&gt;One big question for this year: will there be a Rust 2021 edition? If so, 2020 would be the year to do a lot of associated work and plan the details. What would the edition's theme be?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rust 2015: Stability&lt;/li&gt;
&lt;li&gt;Rust 2018: Productivity&lt;/li&gt;
&lt;li&gt;Rust 2021: ?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let us know what you think!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#please-share-these-posts-with-us&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;please-share-these-posts-with-us&quot;&gt;&lt;/a&gt;Please share these posts with us&lt;/h2&gt;
&lt;p&gt;You can write up these posts and email them to community@rust-lang.org or tweet them with the hashtag #rust2020. If you'd prefer to not participate publicly, emailing something to community@rust-lang.org is fine as well.&lt;/p&gt;
&lt;p&gt;Thanks for helping make Rust awesome! We are looking forward to doing amazing things in 2020.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rustup 1.20.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/10/15/Rustup-1.20.0.html" type="text/html" title="Announcing Rustup 1.20.0" />
        <published>2019-10-15T00:00:00Z</published>
        <updated>2019-10-15T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/10/15/Rustup-1.20.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/10/15/Rustup-1.20.0.html">&lt;p&gt;The rustup working group is happy to announce the release of rustup version 1.20.0. &lt;a href=&quot;https://rustup.rs&quot;&gt;Rustup&lt;/a&gt; is the recommended tool to install &lt;a href=&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt;, a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of rustup installed, getting rustup 1.20.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup self update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rustup will also automatically update itself at the end of a normal toolchain update:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://rustup.rs&quot;&gt;get rustup&lt;/a&gt; from the appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-new-in-rustup-1.20.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-new-in-rustup-1.20.0&quot;&gt;&lt;/a&gt;What's new in rustup 1.20.0&lt;/h2&gt;
&lt;p&gt;The highlights of this release are profiles support, the ability to get the latest available nightly with all the components you need, and improvements to the &lt;code&gt;rustup doc&lt;/code&gt; command. You can also check out &lt;a href=&quot;https://github.com/rust-lang/rustup.rs/blob/master/CHANGELOG.md&quot;&gt;the changelog&lt;/a&gt; for a list of all the changes included in this release.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#profiles&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;profiles&quot;&gt;&lt;/a&gt;Profiles&lt;/h3&gt;
&lt;p&gt;Previous versions of rustup installed a few components by default along with each toolchain: the compiler (&lt;code&gt;rustc&lt;/code&gt;), the package manager (&lt;code&gt;cargo&lt;/code&gt;), the standard library (&lt;code&gt;rust-std&lt;/code&gt;), and offline documentation (&lt;code&gt;rust-docs&lt;/code&gt;). While this approach is fine while developing software locally, some of the components (like &lt;code&gt;rust-docs&lt;/code&gt;) slowed down the installation, either because they're not used on build servers, or on Windows due to the large amount of installed files.&lt;/p&gt;
&lt;p&gt;To address this problem, rustup 1.20.0 introduces the concept of &amp;quot;profiles&amp;quot;. They are groups of components you can choose to download while installing a new Rust toolchain. The profiles available at this time are &lt;code&gt;minimal&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, and &lt;code&gt;complete&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;minimal&lt;/strong&gt; profile includes as few components as possible to get a working compiler (&lt;code&gt;rustc&lt;/code&gt;, &lt;code&gt;rust-std&lt;/code&gt;, and &lt;code&gt;cargo&lt;/code&gt;). It's recommended to use this component on Windows systems if you don't use local documentation, and in CI.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;default&lt;/strong&gt; profile includes all the components previously installed by default (&lt;code&gt;rustc&lt;/code&gt;, &lt;code&gt;rust-std&lt;/code&gt;, &lt;code&gt;cargo&lt;/code&gt;, and &lt;code&gt;rust-docs&lt;/code&gt;) plus &lt;code&gt;rustfmt&lt;/code&gt; and &lt;code&gt;clippy&lt;/code&gt;. This profile will be used by rustup by default, and it's the one recommended for general use.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;complete&lt;/strong&gt; profile includes all the components available through rustup, including &lt;code&gt;miri&lt;/code&gt; and IDE integration tools (&lt;code&gt;rls&lt;/code&gt; and &lt;code&gt;rust-analysis&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To change the rustup profile you can use the &lt;code&gt;rustup set profile&lt;/code&gt; command. For example, to select the minimal profile you can use:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup set profile minimal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's also possible to choose the profile when installing rustup for the first time, either interactively by choosing the &amp;quot;Customize installation&amp;quot; option or programmaticaly by passing the &lt;code&gt;--profile=&amp;lt;name&amp;gt;&lt;/code&gt; flag. Profiles will only affect newly installed toolchains: as usual it will be possible to install individual components later with: &lt;code&gt;rustup component add&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#installing-the-latest-compatible-nightly&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;installing-the-latest-compatible-nightly&quot;&gt;&lt;/a&gt;Installing the latest compatible nightly&lt;/h3&gt;
&lt;p&gt;While most components are guaranteed to be present on stable releases of &lt;a href=&quot;https://forge.rust-lang.org/release/platform-support.html&quot;&gt;tier 1 platforms&lt;/a&gt;, the same guarantee doesn't apply to nightly builds. Frequently, tools such as &lt;code&gt;rustfmt&lt;/code&gt;, &lt;code&gt;clippy&lt;/code&gt;, or &lt;code&gt;rls&lt;/code&gt; are missing in the latest nightly. If you depend on these tools, that makes updating nighties hard, as rustup will prevent the upgrade if a component you previously installed is missing.&lt;/p&gt;
&lt;p&gt;Starting from rustup 1.20.0, if a component you previously installed is missing in the latest nightly, &lt;code&gt;rustup update&lt;/code&gt; will walk backwards in time to find the most recent release with all the components you need. If there are no new nightlies with all the components you need you'll either need to wait or remove some of them.&lt;/p&gt;
&lt;p&gt;Along with this change, rustup 1.20.0 introduces the &lt;code&gt;--component&lt;/code&gt;/&lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;--target&lt;/code&gt;/&lt;code&gt;-t&lt;/code&gt; options to the &lt;code&gt;rustup toolchain install&lt;/code&gt; command, allowing you to add components and targets as the toolchain is installed. These flags will also search past nightlies if the current one does not feature all the requested components.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#improvements-to-rustup-doc&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;improvements-to-rustup-doc&quot;&gt;&lt;/a&gt;Improvements to &lt;code&gt;rustup doc&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;rustup doc&lt;/code&gt; command opens the locally installed documentation on your browser, without any Internet connection required. rustup 1.20.0 enhances the command allowing you to open directly the API documentation of a specific item. For example to look at the documentation of &lt;a href=&quot;https://doc.rust-lang.org/std/iter/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; you can use:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup doc std::iter::Iterator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works for traits, structs/enums, macros, and modules, and can take you to the &lt;code&gt;std&lt;/code&gt;, &lt;code&gt;alloc&lt;/code&gt;, and &lt;code&gt;core&lt;/code&gt; crates. Note, however, that this functionality will only work if you have the &lt;code&gt;rust-docs&lt;/code&gt; component installed in your toolchain. We will be improving the command's UX over time, so if you have ideas, please do let us know!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#thanks&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;thanks&quot;&gt;&lt;/a&gt;Thanks&lt;/h2&gt;
&lt;p&gt;Thanks to all the contributors who made rustup 1.20.0 possible!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Andy McCaffrey&lt;/li&gt;
&lt;li&gt;Artem Borisovskiy&lt;/li&gt;
&lt;li&gt;Benjamin Chen&lt;/li&gt;
&lt;li&gt;Daniel Silverstone&lt;/li&gt;
&lt;li&gt;Jon Gjengset&lt;/li&gt;
&lt;li&gt;Lzu Tao&lt;/li&gt;
&lt;li&gt;Matt Kantor&lt;/li&gt;
&lt;li&gt;Mitchell Hynes&lt;/li&gt;
&lt;li&gt;Nick Cameron&lt;/li&gt;
&lt;li&gt;PicoJr&lt;/li&gt;
&lt;li&gt;Pietro Albini&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>The Rustup Working Group</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing the Inside Rust blog</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/10/03/inside-rust-blog.html" type="text/html" title="Announcing the Inside Rust blog" />
        <published>2019-10-03T00:00:00Z</published>
        <updated>2019-10-03T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/10/03/inside-rust-blog.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/10/03/inside-rust-blog.html">&lt;p&gt;Today we're happy to announce that we're starting a second blog, the
&lt;a href=&quot;/inside-rust/index.html&quot;&gt;&lt;strong&gt;Inside Rust&lt;/strong&gt; blog&lt;/a&gt;. This blog will be used to post regular
updates by the various Rust teams and working groups. If you're
interested in following along with the &amp;quot;nitty gritty&amp;quot; of Rust
development, then you should take a look!&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisory for Cargo</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/09/30/Security-advisory-for-cargo.html" type="text/html" title="Security advisory for Cargo" />
        <published>2019-09-30T00:00:00Z</published>
        <updated>2019-09-30T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/09/30/Security-advisory-for-cargo.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/09/30/Security-advisory-for-cargo.html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This is a cross-post of the &lt;a href=&quot;https://groups.google.com/forum/#!topic/rustlang-security-announcements/rVQ5e3TDnpQ&quot;&gt;official security advisory&lt;/a&gt;. The official
post contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust team was recently notified of a security concern when using older versions of Cargo to build crates which use the package rename feature added in newer versions of Cargo. If you're using Rust 1.26.0, released on 2018-05-10, or later you're not affected.&lt;/p&gt;
&lt;p&gt;The CVE for this vulnerability is &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16760&quot;&gt;CVE-2019-16760&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#overview&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;Cargo can be configured through &lt;code&gt;Cargo.toml&lt;/code&gt; and the &lt;code&gt;[dependencies]&lt;/code&gt; section to depend on different crates, such as those from crates.io. There are multiple ways to configure how you depend on crates as well, for example if you depend on &lt;code&gt;serde&lt;/code&gt; and enable the &lt;code&gt;derive&lt;/code&gt; feature it would look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;serde = { version = &amp;quot;1.0&amp;quot;, features = ['derive'] }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rust 1.31.0 &lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#cargo-features&quot;&gt;introduced a new feature of Cargo&lt;/a&gt; where one of the optional keys you can specify in this map is &lt;code&gt;package&lt;/code&gt;, a way to &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml&quot;&gt;rename a crate locally&lt;/a&gt;. For example if you preferred to use &lt;code&gt;serde1&lt;/code&gt; locally instead of &lt;code&gt;serde&lt;/code&gt;, you could write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;serde1 = { version = &amp;quot;1.0&amp;quot;, features = ['derive'], package = &amp;quot;serde&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's the addition of the &lt;code&gt;package&lt;/code&gt; key that causes Cargo to compile the crate differently. This feature was &lt;a href=&quot;https://github.com/rust-lang/cargo/pull/4953&quot;&gt;first implemented&lt;/a&gt; in Rust 1.26.0, but it was unstable at the time. For Rust 1.25.0 and prior, however, Cargo would ignore the &lt;code&gt;package&lt;/code&gt; key and and interpret the dependency line as if it were:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;serde1 = { version = &amp;quot;1.0&amp;quot;, features = ['derive'] }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means when compiled with Rust 1.25.0 and prior then it would attempt to download the &lt;code&gt;serde1&lt;/code&gt; crate. A malicious user could squat the &lt;code&gt;serde1&lt;/code&gt; name on crates.io to look like &lt;code&gt;serde 1.0.0&lt;/code&gt; but instead act maliciously when built.&lt;/p&gt;
&lt;p&gt;In summary, usage of the &lt;code&gt;package&lt;/code&gt; key to rename dependencies in &lt;code&gt;Cargo.toml&lt;/code&gt; is ignored in Rust 1.25.0 and prior. When Rust 1.25.0 and prior is used Cargo will ignore &lt;code&gt;package&lt;/code&gt; and download the wrong dependency, which could be squatted on crates.io to be a malicious package. This not only affects manifests that you write locally yourself, but also manifests published to crates.io. If you published a crate, for example, that depends on &lt;code&gt;serde1&lt;/code&gt; to crates.io then users who depend on you may also be vulnerable if they use Rust 1.25.0 and prior.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#affected-versions&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected Versions&lt;/h2&gt;
&lt;p&gt;Rust 1.0.0 through Rust 1.25.0 is affected by this advisory because Cargo will ignore the &lt;code&gt;package&lt;/code&gt; key in manifests. Rust 1.26.0 through Rust 1.30.0 are not affected and typically will emit an error because the &lt;code&gt;package&lt;/code&gt; key is unstable. Rust 1.31.0 and after are not affected because Cargo understands the &lt;code&gt;package&lt;/code&gt; key.&lt;/p&gt;
&lt;p&gt;In terms of Cargo versions, this affects Cargo up through Cargo 0.26.0. All future versions of Cargo are unaffected.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#mitigations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;We strongly recommend that users of the affected versions update their compiler to the latest available one. Preventing this issue from happening requires updating your compiler to either Rust 1.26.0 or newer.&lt;/p&gt;
&lt;p&gt;We will not be issuing a patch release for Rust versions prior to 1.26.0. Users of Rust 1.19.0 to Rust 1.25.0 can instead apply &lt;a href=&quot;https://gist.github.com/pietroalbini/0d293b24a44babbeb6187e06eebd4992&quot;&gt;the provided patches&lt;/a&gt; to mitigate the issue.&lt;/p&gt;
&lt;p&gt;An audit of existing crates published to crates.io using the &lt;code&gt;package&lt;/code&gt; key has been performed and there is no evidence that this vulnerability has been exploited in the wild. Our audit only covers the crates currently published on crates.io: if you notice crates exploiting this vulnerability in the future please don't hesitate to email security@rust-lang.org in accordance with &lt;a href=&quot;https://www.rust-lang.org/policies/security&quot;&gt;our security policy&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#timeline-of-events&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;timeline-of-events&quot;&gt;&lt;/a&gt;Timeline of events&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Wed, Sep 18, 2019 at 13:54 UTC - Bug reported to security@rust-lang.org&lt;/li&gt;
&lt;li&gt;Wed, Sep 18, 2019 at 15:35 UTC - Response confirming the report&lt;/li&gt;
&lt;li&gt;Wed, Sep 18, 2019 - Cargo, Core, and crates.io teams confer on how best to handle this&lt;/li&gt;
&lt;li&gt;Thu, Sep 19, 2019 - Confirmed with Elichai plan of action and continued to audit existing crates&lt;/li&gt;
&lt;li&gt;Mon, Sep 23, 2019 - Advisory drafted, patches developed, audit completed&lt;/li&gt;
&lt;li&gt;Mon, Sep 30, 2019 - Advisory published, security list informed of this issue&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#acknowledgments&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;acknowledgments&quot;&gt;&lt;/a&gt;Acknowledgments&lt;/h2&gt;
&lt;p&gt;Thanks to Elichai Turkel, who found this bug and reported it to us in accordance
with our &lt;a href=&quot;https://www.rust-lang.org/policies/security&quot;&gt;security policy&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Async-await hits beta!</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/09/30/Async-await-hits-beta.html" type="text/html" title="Async-await hits beta!" />
        <published>2019-09-30T00:00:00Z</published>
        <updated>2019-09-30T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/09/30/Async-await-hits-beta.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/09/30/Async-await-hits-beta.html">&lt;p&gt;Big news! As of this writing, &lt;strong&gt;syntactic support for async-await is
available in the Rust beta channel!&lt;/strong&gt; It will be available in the 1.39
release, which is expected to be released on &lt;strong&gt;November 7th, 2019&lt;/strong&gt;.
Once async-await hits stable, that will mark the culmination of a
&lt;strong&gt;multi-year effort to enable efficient and ergonomic asynchronous I/O
in Rust&lt;/strong&gt;. It will not, however, mark the end of the road: there is
still more work to do, both in terms of polish (some of the error
messages we get today are, um, &lt;a href=&quot;https://github.com/rust-lang/rust/issues/64130&quot;&gt;not great&lt;/a&gt;) and in terms of feature
set (&lt;a href=&quot;https://github.com/dtolnay/async-trait&quot;&gt;async fn in traits&lt;/a&gt;, anyone?).&lt;/p&gt;
&lt;p&gt;(If you're not familiar with what async-await is, don't despair!
There's a primer and other details later on in this post!)&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#async-await-support-in-the-ecosystem-growing-rapidly&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;async-await-support-in-the-ecosystem-growing-rapidly&quot;&gt;&lt;/a&gt;Async-await support in the ecosystem growing rapidly&lt;/h3&gt;
&lt;p&gt;But async-await has never been the entire story. To make good use of
async-await, you also need strong libraries and a vibrant ecosystem.
&lt;strong&gt;Fortunately, you've got a lot of good choices, and they keep getting
better:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the async runtime &lt;a href=&quot;https://tokio.rs/&quot;&gt;tokio&lt;/a&gt;, for example, recently announced an &lt;a href=&quot;https://tokio.rs/blog/2019-08-alphas/&quot;&gt;alpha
release&lt;/a&gt; based on async-await;&lt;/li&gt;
&lt;li&gt;the &lt;a href=&quot;https://async.rs/blog/announcing-async-std/&quot;&gt;recently announced&lt;/a&gt; &lt;a href=&quot;https://async.rs/&quot;&gt;async-std&lt;/a&gt; library was built from the
start on the new async-await syntax;&lt;/li&gt;
&lt;li&gt;using &lt;a href=&quot;https://docs.rs/crate/wasm-bindgen-futures/0.2.16&quot;&gt;wasm-bindgen-futures&lt;/a&gt;, you can even bridge Rust Futures with
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;JavaScript promises&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;the &lt;a href=&quot;https://hyper.rs&quot;&gt;hyper library&lt;/a&gt; has &lt;a href=&quot;https://github.com/hyperium/hyper/issues/1805&quot;&gt;migrated&lt;/a&gt; to adopt standard Rust futures;&lt;/li&gt;
&lt;li&gt;the 0.3.0 version of the &lt;a href=&quot;https://crates.io/crates/futures-preview&quot;&gt;futures-rs library&lt;/a&gt; will support
async-await and will be released by the time async-await hits stable
(you can use the &lt;a href=&quot;https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/19/futures-0.3.0-alpha.1.html&quot;&gt;0.3.0-alpha&lt;/a&gt; releases now);&lt;/li&gt;
&lt;li&gt;finally, async-await support is starting to become available in higher-level
&lt;a href=&quot;https://www.arewewebyet.org/topics/frameworks/&quot;&gt;web frameworks&lt;/a&gt; as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#restructuring-async-io-in-the-rust-org&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;restructuring-async-io-in-the-rust-org&quot;&gt;&lt;/a&gt;Restructuring Async I/O in the Rust org&lt;/h3&gt;
&lt;p&gt;Now that async-await is approaching stable, we are taking the
opportunity to make some changes to our Rust team structure. The
current structure includes two working groups: the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/&quot;&gt;Async Foundations
WG&lt;/a&gt;, focused on building up core language support, and the &lt;a href=&quot;https://github.com/rustasync/team&quot;&gt;Async
Ecosystem WG&lt;/a&gt;, focused on supporting the ecosystem develop.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In light of all the activity going on in the ecosystem, however,
there it not as much need for the &lt;a href=&quot;https://github.com/rustasync/team&quot;&gt;Async Ecosystem WG&lt;/a&gt;, and as such
we've decided to spin it down.&lt;/strong&gt; We'll be deprecating the &lt;a href=&quot;https://github.com/rustasync/&quot;&gt;rustasync
github org&lt;/a&gt;. The &lt;a href=&quot;https://areweasyncyet.rs/&quot;&gt;areweasyncyet.rs&lt;/a&gt; and &lt;a href=&quot;https://www.arewewebyet.org/&quot;&gt;arewewebyet.org&lt;/a&gt; websites
will move to the main &lt;a href=&quot;https://github.com/rust-lang/&quot;&gt;rust-lang org&lt;/a&gt;, but the fate of the other
projects will be decided by the people who built them. A few will
likely be deprecated, and the remainder will be moving out to be
maintained independently.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/&quot;&gt;Async Foundations WG&lt;/a&gt;, meanwhile, will continue, but with a
shift in focus.&lt;/strong&gt; Now that async-await is en route to stabilization,
the focus will be on polish, such as improving diagnostics, fixing
smaller bugs, and improving documentation such as the &lt;a href=&quot;https://github.com/rust-lang/async-book&quot;&gt;async
book&lt;/a&gt;. Once progress is made on that, we'll be considering what
features to implement next.&lt;/p&gt;
&lt;p&gt;(An aside: this is the first time that we've ever opted to spin &lt;em&gt;down&lt;/em&gt;
a working group, and we realized that we don't have a formal policy
for that. We've &lt;a href=&quot;https://github.com/rust-lang/wg-governance/issues/25&quot;&gt;created an issue&lt;/a&gt; with the &lt;a href=&quot;https://github.com/rust-lang/wg-governance/&quot;&gt;governance working
group&lt;/a&gt; to look into that for the future.)&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#async-await-a-quick-primer&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;async-await-a-quick-primer&quot;&gt;&lt;/a&gt;Async await: a quick primer&lt;/h3&gt;
&lt;p&gt;So, what is async await? Async-await is a way to write functions that
can &amp;quot;pause&amp;quot;, return control to the runtime, and then pick up from
where they left off.  Typically those pauses are to wait for I/O, but
there can be any number of uses.&lt;/p&gt;
&lt;p&gt;You may be familiar with the async-await from other languages, such as
JavaScript or C#. Rust's version of the feature is similar, but with a
few key differences.&lt;/p&gt;
&lt;p&gt;To use async-await, you start by writing &lt;code&gt;async fn&lt;/code&gt; instead of &lt;code&gt;fn&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn first_function() -&amp;gt; u32 { .. }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unlike a regular function, calling an &lt;code&gt;async fn&lt;/code&gt; doesn't do anything
to start -- instead, it returns a &lt;code&gt;Future&lt;/code&gt;. This is a suspended
computation that is waiting to be executed. To actually &lt;em&gt;execute&lt;/em&gt;
the future, you have to use the &lt;code&gt;.await&lt;/code&gt; operator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn another_function() {
    // Create the future:
    let future = first_function();
    
    // Await the future, which will execute it (and suspend
    // this function if we encounter a need to wait for I/O): 
    let result: u32 = future.await;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This example shows the first difference between Rust and other
languages: we write &lt;code&gt;future.await&lt;/code&gt; instead of &lt;code&gt;await future&lt;/code&gt;. This
syntax integrates better with Rust's &lt;code&gt;?&lt;/code&gt; operator for propagating
errors (which, after all, are very common in I/O). One can simply
write &lt;code&gt;future.await?&lt;/code&gt; to await the result of a future and propagate
errors. It also has the advantage of making method chaining painless.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#zero-cost-futures&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;zero-cost-futures&quot;&gt;&lt;/a&gt;Zero-cost futures&lt;/h3&gt;
&lt;p&gt;The other difference between Rust futures and futures in other
languages is that they are based on a &amp;quot;poll&amp;quot; model, which makes them
&lt;strong&gt;zero cost&lt;/strong&gt;. In other languages, invoking an async function
immediately creates a future and schedules it for execution: awaiting
the future isn't really necessary for it to execute. But this implies
some overhead for each future that is created.&lt;/p&gt;
&lt;p&gt;In contrast, in Rust, calling an async function does not do any
scheduling in and of itself, which means that we can compose a complex
nest of futures without incurring a per-future cost. As an end-user,
though, the main thing you'll notice is that &lt;strong&gt;futures feel &amp;quot;lazy&amp;quot;&lt;/strong&gt;:
they don't do anything until you await them.&lt;/p&gt;
&lt;p&gt;If you'd like a closer look at how futures work under the hood, take a
look at &lt;a href=&quot;https://rust-lang.github.io/async-book/02_execution/04_executor.html&quot;&gt;the executor section&lt;/a&gt; of the &lt;a href=&quot;https://github.com/rust-lang/async-book&quot;&gt;async book&lt;/a&gt;, or watch the
&lt;a href=&quot;https://www.youtube.com/watch?v=skos4B5x7qE&quot;&gt;excellent talk&lt;/a&gt; that &lt;a href=&quot;https://github.com/withoutboats&quot;&gt;withoutboats&lt;/a&gt; gave at &lt;a href=&quot;https://rustlatam.org/&quot;&gt;Rust LATAM 2019&lt;/a&gt;
on the topic.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#summary&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;summary&quot;&gt;&lt;/a&gt;Summary&lt;/h3&gt;
&lt;p&gt;In summary, if you've an interest in using Async I/O in Rust, this is
a very exciting time! With async-await syntax hitting stable in
November, it's going to be easier than ever to write futures (in
particular, if you tried using the combinator-based futures in the
past, you'll find &lt;a href=&quot;http://aturon.github.io/tech/2018/04/24/async-borrowing/&quot;&gt;async-await integrates much better with Rust's
borrowing system&lt;/a&gt;). Moreover, there are now a number of great
runtimes and other libraries available in the ecosystem to work with.
So get out there and build stuff!&lt;/p&gt;
&lt;p&gt;(Oh, yeah, and please file bugs when you hit confusing or surprising
problems, so we can improve the user experience!)&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.38.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/09/26/Rust-1.38.0.html" type="text/html" title="Announcing Rust 1.38.0" />
        <published>2019-09-26T00:00:00Z</published>
        <updated>2019-09-26T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/09/26/Rust-1.38.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/09/26/Rust-1.38.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.38.0. Rust is a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.38.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.38.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.38.0-stable&quot;&gt;&lt;/a&gt;What's in 1.38.0 stable&lt;/h2&gt;
&lt;p&gt;The highlight of this release is pipelined compilation.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#pipelined-compilation&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;pipelined-compilation&quot;&gt;&lt;/a&gt;Pipelined compilation&lt;/h3&gt;
&lt;p&gt;To compile a crate, the compiler doesn't need the dependencies to be fully built. Instead, it just needs their &amp;quot;metadata&amp;quot; (i.e. the list of types, dependencies, exports...). This metadata is produced early in the compilation process. Starting with Rust 1.38.0, Cargo will take advantage of this by automatically starting to build dependent crates as soon as metadata is ready.&lt;/p&gt;
&lt;p&gt;While the change doesn't have any effect on builds for a single crate, during testing &lt;a href=&quot;https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199&quot;&gt;we got reports&lt;/a&gt; of 10-20% compilation speed increases for optimized, clean builds of some crate graphs. Other ones did not improve much, and the speedup depends on the hardware running the build, so your mileage might vary. No code changes are needed to benefit from this.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#linting-some-incorrect-uses-of-mem:{uninitialized,-zeroed}&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;linting-some-incorrect-uses-of-mem:{uninitialized,-zeroed}&quot;&gt;&lt;/a&gt;Linting some incorrect uses of &lt;code&gt;mem::{uninitialized, zeroed}&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;As &lt;a href=&quot;https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html#maybeuninitt%3E-instead-of-mem::uninitialized&quot;&gt;previously announced&lt;/a&gt;, &lt;code&gt;std::mem::uninitialized&lt;/code&gt; is essentially impossible to use safely. Instead, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; should be used.&lt;/p&gt;
&lt;p&gt;We have not yet deprecated &lt;code&gt;mem::uninitialized&lt;/code&gt;; this will be done in a future release. Starting in 1.38.0, however, &lt;code&gt;rustc&lt;/code&gt; will provide a lint for a narrow class of incorrect initializations using &lt;code&gt;mem::uninitialized&lt;/code&gt; or &lt;code&gt;mem::zeroed&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It is undefined behavior for some types, such as &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, to ever contain an all-&lt;code&gt;0&lt;/code&gt; bit pattern, because they represent pointer-like objects that cannot be &lt;code&gt;null&lt;/code&gt;. It is therefore an error to use &lt;code&gt;mem::uninitialized&lt;/code&gt; or &lt;code&gt;mem::zeroed&lt;/code&gt; to initialize one of these types, so the new lint will attempt to warn whenever one of those functions is used to initialize one of them, either directly or as a member of a larger &lt;code&gt;struct&lt;/code&gt;. The check is recursive, so the following code will emit a warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;struct Wrap&amp;lt;T&amp;gt;(T);
struct Outer(Wrap&amp;lt;Wrap&amp;lt;Wrap&amp;lt;Box&amp;lt;i32&amp;gt;&amp;gt;&amp;gt;&amp;gt;);
struct CannotBeZero {
    outer: Outer,
    foo: i32,
    bar: f32
}

...

let bad_value: CannotBeZero = unsafe { std::mem::uninitialized() };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Astute readers may note that Rust has more types that cannot be zero, notably &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;NonZero&amp;lt;T&amp;gt;&lt;/code&gt;. For now, initialization of these structs with &lt;code&gt;mem::uninitialized&lt;/code&gt; or &lt;code&gt;mem::zeroed&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; linted against.&lt;/p&gt;
&lt;p&gt;These checks do not cover all cases of unsound use of &lt;code&gt;mem::uninitialized&lt;/code&gt; or &lt;code&gt;mem::zeroed&lt;/code&gt;, they merely help identify code that is definitely wrong. All code should still be moved to use &lt;code&gt;MaybeUninit&lt;/code&gt; instead.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#[deprecated]-macros&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;[deprecated]-macros&quot;&gt;&lt;/a&gt;&lt;code&gt;#[deprecated]&lt;/code&gt; macros&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;#[deprecated]&lt;/code&gt; attribute, first introduced in Rust 1.9.0, allows crate authors to notify their users an item of their crate is deprecated and will be removed in a future release. Rust 1.38.0 extends the attribute, allowing it to be applied to macros as well.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#std:any::type_name&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;std:any::type_name&quot;&gt;&lt;/a&gt;&lt;code&gt;std::any::type_name&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;For debugging, it is sometimes useful to get the name of a type. For instance, in generic code, you may want to see, at run-time, what concrete types a function's type parameters has been instantiated with. This can now be done using &lt;code&gt;std::any::type_name&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn gen_value&amp;lt;T: Default&amp;gt;() -&amp;gt; T {
    println!(&amp;quot;Initializing an instance of {}&amp;quot;, std::any::type_name::&amp;lt;T&amp;gt;());
    Default::default()
}

fn main() {
    let _: i32 = gen_value();
    let _: String = gen_value();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This prints:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Initializing an instance of i32
Initializing an instance of alloc::string::String
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Like all standard library functions intended only for debugging, the exact contents and format of the string are not guaranteed. The value returned is only a best-effort description of the type; multiple types may share the same &lt;code&gt;type_name&lt;/code&gt; value, and the value may change in future compiler releases.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-changes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-changes&quot;&gt;&lt;/a&gt;Library changes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/62528/&quot;&gt;&lt;code&gt;slice::{concat, connect, join}&lt;/code&gt; now accepts &lt;code&gt;&amp;amp;[T]&lt;/code&gt; in addition to &lt;code&gt;&amp;amp;T&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/62583/&quot;&gt;&lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt; now implement &lt;code&gt;marker::Unpin&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/61953/&quot;&gt;&lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt; and &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt; now implement &lt;code&gt;FromIterator&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/61457/&quot;&gt;&lt;code&gt;iter::{StepBy, Peekable, Take}&lt;/code&gt; now implement &lt;code&gt;DoubleEndedIterator&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, these functions have been stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.pointer.html#method.cast&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::cast&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.pointer.html#method.cast-1&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::cast&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f32&quot;&gt;&lt;code&gt;Duration::as_secs_f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f64&quot;&gt;&lt;code&gt;Duration::as_secs_f64&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f32&quot;&gt;&lt;code&gt;Duration::div_f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f64&quot;&gt;&lt;code&gt;Duration::div_f64&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs_f32&quot;&gt;&lt;code&gt;Duration::from_secs_f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs_f64&quot;&gt;&lt;code&gt;Duration::from_secs_f64&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f32&quot;&gt;&lt;code&gt;Duration::mul_f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f64&quot;&gt;&lt;code&gt;Duration::mul_f64&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Euclidean remainder and division operations -- &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.i32.html#method.div_euclid&quot;&gt;&lt;code&gt;div_euclid&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.i32.html#method.rem_euclid&quot;&gt;&lt;code&gt;rem_euclid&lt;/code&gt;&lt;/a&gt; -- for all integer primitives. &lt;code&gt;checked&lt;/code&gt;,
&lt;code&gt;overflowing&lt;/code&gt;, and &lt;code&gt;wrapping&lt;/code&gt; versions are also available.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#other-changes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.38 release: check out what changed in &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1380-2019-09-26&quot;&gt;Rust&lt;/a&gt;, &lt;a href=&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-138-2019-09-26&quot;&gt;Cargo&lt;/a&gt;, and &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-138&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#corrections&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;corrections&quot;&gt;&lt;/a&gt;Corrections&lt;/h3&gt;
&lt;p&gt;A Previous version of this post mistakenly marked these functions as stable. They are not yet stable.
&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f32&quot;&gt;&lt;code&gt;Duration::div_duration_f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f64&quot;&gt;&lt;code&gt;Duration::div_duration_f64&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-138.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-138.0&quot;&gt;&lt;/a&gt;Contributors to 1.38.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.38.0. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.38.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
</feed>
